<!DOCTYPE html><html lang="en"><head>
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com;
        connect-src 'self' https://text.pollinations.ai;
        frame-src 'self' https://www.youtube.com https://trytako.com;
        child-src 'self';
        manifest-src 'self';
        worker-src 'self';
        upgrade-insecure-requests;
        block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowchart Creator by Minecraft AI</title>
    <link rel="icon" type="image/x-icon" href="icon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            background: linear-gradient(135deg, #6d9dc5 0%, #8fbc8f 100%);
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .toolbar {
            background: linear-gradient(135deg, #4a4a4a 0%, #2d2d2d 100%);
            padding: 15px 20px;
            border-bottom: 3px solid #8b4513;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            border-image: repeating-linear-gradient(
                90deg,
                #8b4513 0px,
                #8b4513 4px,
                #654321 4px,
                #654321 8px
            ) 3;
            z-index: 10;
        }

        .title-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .toolbar h1 {
            font-size: 20px;
            color: #ffffff;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-family: 'Courier New', monospace;
        }

        .minecraft-decoration {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .minecraft-block {
            width: 20px;
            height: 20px;
            border: 2px solid #000;
            position: relative;
            image-rendering: pixelated;
        }

        .block-dirt {
            background: linear-gradient(45deg, #8b4513 25%, #a0522d 25%, #a0522d 50%, #8b4513 50%, #8b4513 75%, #a0522d 75%);
            background-size: 4px 4px;
        }

        .block-grass {
            background: linear-gradient(to bottom, #9acd32 0%, #9acd32 30%, #8b4513 30%, #8b4513 70%, #a0522d 70%);
        }

        .block-stone {
            background: linear-gradient(45deg, #696969 25%, #808080 25%, #808080 50%, #696969 50%, #696969 75%, #808080 75%);
            background-size: 3px 3px;
        }
        
        .discord-link {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 180px;
            gap: 8px;
            color: #1da1f2;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid #1da1f2;
            transition: all 0.2s;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
        }

        .discord-link:hover {
            background: #1da1f2;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(29, 161, 242, 0.4);
        }

        .discord-icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .github-link {
            width: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: #1da1f2;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid #1da1f2;
            transition: all 0.2s;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
        }

        .github-link:hover {
            background: #1da1f2;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(29, 161, 242, 0.4);
        }

        .github-icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .twitter-link {
            width: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: #1da1f2;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid #1da1f2;
            transition: all 0.2s;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
        }

        .twitter-link:hover {
            background: #1da1f2;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(29, 161, 242, 0.4);
        }

        .twitter-icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .toolbar-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .toolbar-row:last-child {
            margin-bottom: 0;
        }

        .tool-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px 12px;
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            border-radius: 6px;
            border: 2px solid #8b4513;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.5), 0 2px 4px rgba(0,0,0,0.2);
        }

        .tool-group-label {
            font-size: 11px;
            color: #4a4a4a;
            font-weight: 700;
            margin-right: 5px;
            text-transform: uppercase;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
            font-family: 'Courier New', monospace;
        }

        .tool-btn {
            padding: 8px 14px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            font-weight: 400;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
        }

        .tool-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-color: #2e7d32;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .tool-btn.delete {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
            border-color: #b71c1c;
        }

        .tool-btn.delete:hover {
            background: linear-gradient(135deg, #d32f2f 0%, #b71c1c 100%);
        }

        .tool-btn.delete:disabled {
            background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%);
            border-color: #616161;
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Color Selection Styles */
        .color-selector {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-palette {
            flex: 1;
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 2px;
            cursor: pointer;
            border: 2px solid #8b4513;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 1px 2px rgba(0,0,0,0.3);
            transition: all 0.2s;
            image-rendering: pixelated;
        }

        .color-option:hover {
            transform: scale(1.15);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 2px 6px rgba(0,0,0,0.4);
        }

        .color-option.active {
            transform: scale(1.15);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 0 0 3px #4CAF50;
        }

        .current-color-display {
            width: 30px;
            height: 24px;
            border-radius: 2px;
            border: 2px solid #8b4513;
            background: #f0f8ff;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 1px 2px rgba(0,0,0,0.3);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: linear-gradient(45deg, #e8f4f8 25%, #f0f8ff 25%, #f0f8ff 50%, #e8f4f8 50%, #e8f4f8 75%, #f0f8ff 75%);
            background-size: 20px 20px;
            overflow: hidden;
            border: 3px solid #8b4513;
        }

        .canvas-wrapper {
            position: absolute;
            width: 3000px;
            height: 3000px;
            transform-origin: 0 0;
            background: linear-gradient(45deg, #e8f4f8 25%, #f0f8ff 25%, #f0f8ff 50%, #e8f4f8 50%, #e8f4f8 75%, #f0f8ff 75%);
            background-size: 20px 20px;
        }

        #canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #canvas.select-mode {
            cursor: default;
        }
        
        #canvas.pan-mode {
            cursor: grab;
        }
        
        #canvas.panning {
            cursor: grabbing;
        }

        .shape {
            cursor: move;
            stroke: #333;
            stroke-width: 2;
            fill: #f0f8ff;
        }

        .shape:hover {
            stroke: #4CAF50;
            stroke-width: 3;
        }

        .shape.selected {
            stroke: #4CAF50;
            stroke-width: 3;
            stroke-dasharray: 5,5;
        }

        .shape-text, .free-text {
    fill: #000000;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
            fill: #333;
            font-weight: bold;
        }

        .free-text {
    fill: #000000;
            cursor: move;
            pointer-events: all;
        }

        .free-text.selected {
            fill: #4CAF50;
        }

        .arrow {
            stroke: #333;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
            cursor: pointer;
        }

        .arrow:hover {
            stroke: #4CAF50;
            stroke-width: 4;
            cursor: pointer;
        }

        .arrow.selected {
            stroke: #4CAF50;
            stroke-width: 4;
            stroke-dasharray: 8,4;
        }

        .text-input {
            position: absolute;
            border: 2px solid #4CAF50;
            padding: 4px;
            font-size: 14px;
            text-align: left;
            background: white;
            z-index: 1000;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            line-height: 1.2;
        }

        .text-input:focus {
            outline: none;
            border-color: #45a049;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .resize-handle {
            fill: #4CAF50;
            stroke: white;
            stroke-width: 2;
            cursor: nw-resize;
            opacity: 0.8;
        }

        .resize-handle:hover {
            opacity: 1;
            fill: #45a049;
        }

        .resize-handles {
            display: none;
        }

        .shape-group.selected .resize-handles {
            display: block;
        }

        .connection-point {
            fill: #ff9800;
            stroke: white;
            stroke-width: 2;
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .connection-point:hover {
            opacity: 1;
            fill: #f57c00;
        }

        .connection-points {
            display: none;
        }

        .shape-group:hover .connection-points {
            display: block;
        }

        .shape-group:hover .connection-point {
            opacity: 0.7;
        }

        .connection-points.arrow-mode {
            display: block;
        }

        .connection-points.arrow-mode .connection-point {
            opacity: 1;
        }

        .arrow-endpoint {
            fill: #ffeb3b;
            stroke: #333;
            stroke-width: 2;
            cursor: move;
            opacity: 0;
        }

        .arrow-endpoints {
            display: none;
        }

        .arrow-group.selected .arrow-endpoints {
            display: block;
        }

        .arrow-group.selected .arrow-endpoint {
            opacity: 1;
        }

        .arrow-endpoint:hover {
            fill: #fdd835;
            opacity: 1;
        }

        .status-bar {
            background: linear-gradient(135deg, #4a4a4a 0%, #2d2d2d 100%);
            padding: 8px 20px;
            font-size: 12px;
            color: #ffffff;
            border-top: 3px solid #8b4513;
            font-family: 'Courier New', monospace;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .selection-info {
            font-weight: bold;
            color: #4CAF50;
        }

        .arrow-selection-area {
            stroke: transparent;
            stroke-width: 10;
            fill: none;
            cursor: pointer;
        }

        /* Color picker disabled state */
        .color-selector.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .color-selector.disabled .tool-group-label {
            color: #adb5bd;
        }

        /* Minecraft-style pixelated elements */
        .pixelated {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* AI Generator Styles */
        .ai-generator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-grow: 1; 
            min-width: 0;
        }

        .ai-input {
            flex: 1;
            border: 2px solid #8b4513;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            background: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .ai-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1), 0 0 0 3px rgba(76, 175, 80, 0.2);
        }

        .ai-generate-btn {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            display: flex;
            width : 220px;
            line-height : 1.5;
            color: white;
            border: 2px solid #e65100;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-family: 'Courier New', monospace;
        }

        .ai-generate-btn:hover {
            background: linear-gradient(135deg, #f57c00 0%, #ef6c00 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .ai-generate-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .ai-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .ai-modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .ai-modal-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border: 3px solid #8b4513;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .ai-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }

        .ai-modal-title {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #4a4a4a;
        }

        .ai-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #9e9e9e;
            transition: color 0.2s;
        }

        .ai-modal-close:hover {
            color: #f44336;
        }

        .ai-modal-message {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: #333;
            border-left: 4px solid #8b4513;
        }

        .ai-error {
            border-left-color: #f44336;
            color: #d32f2f;
        }

        .ai-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }

        .ai-modal-btn {
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        .ai-primary-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: 2px solid #2e7d32;
        }

        .ai-primary-btn:hover {
            background: linear-gradient(135deg, #45a049 0%, #388e3c 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
        }

        .ai-secondary-btn {
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            color: #4a4a4a;
            border: 2px solid #9e9e9e;
        }

        .ai-secondary-btn:hover {
            background: linear-gradient(135deg, #e0e0e0 0%, #d5d5d5 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }

        /* Canvas controls */
        .canvas-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .zoom-level {
            font-weight: bold;
            color: #ff9800;
            padding: 4px 8px;
            background: rgba(0,0,0,0.2);
            width: 50px;
            text-align: center;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .zoom-btn {
            background: linear-gradient(135deg, #616161 0%, #424242 100%);
            color: white;
            border: 1px solid #212121;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        
        .zoom-btn:hover {
            background: linear-gradient(135deg, #757575 0%, #616161 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        .tool-btn.pan-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
    </style>
</head>
<body>
    <div class="app-container">
        <div class="toolbar">
            <div class="title-bar">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <h1>‚õèÔ∏è Flowchart Creator by Minecraft AI</h1>
                    <div class="minecraft-decoration">
                        <div class="minecraft-block block-grass pixelated"></div>
                        <div class="minecraft-block block-dirt pixelated"></div>
                        <div class="minecraft-block block-stone pixelated"></div>
                    </div>
                </div>
                <div style="display: flex; align-items: right; gap: 15px;">
                    <a href="https://discord.gg/RKjspnTBmb" target="_blank" rel="noopener noreferrer" class="discord-link">
                        <svg class="github-icon" viewBox="0 0 24 24">
                            <path d="M19.952,5.672c-1.904-1.531-4.916-1.79-5.044-1.801c-0.201-0.017-0.392,0.097-0.474,0.281 c-0.006,0.012-0.072,0.163-0.145,0.398c1.259,0.212,2.806,0.64,4.206,1.509c0.224,0.139,0.293,0.434,0.154,0.659 c-0.09,0.146-0.247,0.226-0.407,0.226c-0.086,0-0.173-0.023-0.252-0.072C15.584,5.38,12.578,5.305,12,5.305S8.415,5.38,6.011,6.872 c-0.225,0.14-0.519,0.07-0.659-0.154c-0.14-0.225-0.07-0.519,0.154-0.659c1.4-0.868,2.946-1.297,4.206-1.509 c-0.074-0.236-0.14-0.386-0.145-0.398C9.484,3.968,9.294,3.852,9.092,3.872c-0.127,0.01-3.139,0.269-5.069,1.822 C3.015,6.625,1,12.073,1,16.783c0,0.083,0.022,0.165,0.063,0.237c1.391,2.443,5.185,3.083,6.05,3.111c0.005,0,0.01,0,0.015,0 c0.153,0,0.297-0.073,0.387-0.197l0.875-1.202c-2.359-0.61-3.564-1.645-3.634-1.706c-0.198-0.175-0.217-0.477-0.042-0.675 c0.175-0.198,0.476-0.217,0.674-0.043c0.029,0.026,2.248,1.909,6.612,1.909c4.372,0,6.591-1.891,6.613-1.91 c0.198-0.172,0.5-0.154,0.674,0.045c0.174,0.198,0.155,0.499-0.042,0.673c-0.07,0.062-1.275,1.096-3.634,1.706l0.875,1.202 c0.09,0.124,0.234,0.197,0.387,0.197c0.005,0,0.01,0,0.015,0c0.865-0.027,4.659-0.667,6.05-3.111 C22.978,16.947,23,16.866,23,16.783C23,12.073,20.985,6.625,19.952,5.672z M8.891,14.87c-0.924,0-1.674-0.857-1.674-1.913 s0.749-1.913,1.674-1.913s1.674,0.857,1.674,1.913S9.816,14.87,8.891,14.87z M15.109,14.87c-0.924,0-1.674-0.857-1.674-1.913 s0.749-1.913,1.674-1.913c0.924,0,1.674,0.857,1.674,1.913S16.033,14.87,15.109,14.87z"></path>
                        </svg>
                        Discord Server
                    </a>
                    <a href="https://github.com/aeromechanic000/flowchart-creator" target="_blank" rel="noopener noreferrer" class="github-link">
                        <svg class="github-icon" viewBox="0 0 24 24">
                            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                        </svg>
    
                        GitHub Repository
                    </a>
                    <a href="https://x.com/aeromechan71402" target="_blank" rel="noopener noreferrer" class="twitter-link">
                        <svg class="twitter-icon" viewBox="0 0 24 24">
                            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path>
                        </svg>
                        @aeromechan71402
                    </a>
                </div>
            </div>
            
            <!-- Row 1: Modes, Shapes and Navigation -->
            <div class="toolbar-row">
                <!-- Mode Controls -->
                <div class="tool-group">
                    <span class="tool-group-label">üèÅ Mode</span>
                    <button onclick="setMode('select')" class="tool-btn active">Select</button>
                    <button onclick="setMode('text')" class="tool-btn">Free Text</button>
                    <button onclick="setMode('arrow')" class="tool-btn">Arrow</button>
                    <button onclick="setMode('pan')" class="tool-btn pan-btn">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 1v22M1 12h22M4 4l16 16M4 20L20 4"></path>
                        </svg>
                        Pan
                    </button>
                </div>
                
                <!-- Navigation Controls -->
                <div class="tool-group">
                    <span class="tool-group-label">üîç View</span>
                    <button onclick="zoomIn()" class="zoom-btn" title="Zoom In">+</button>
                    <span class="zoom-level" id="zoom-level">100%</span>
                    <button onclick="zoomOut()" class="zoom-btn" title="Zoom Out">-</button>
                    <button onclick="resetZoom()" class="tool-btn">Reset</button>
                </div>
                
                <!-- File Controls -->
                <div class="tool-group">
                    <span class="tool-group-label">üì¶ File</span>
                    <button onclick="exportJSON()" class="tool-btn">Export JSON</button>
                    <button onclick="exportSVG()" class="tool-btn">Export SVG</button>
                    <input type="file" id="import-json" accept=".json" style="display: none;" onchange="importJSON(this)">
                    <button onclick="document.getElementById('import-json').click()" class="tool-btn">Import JSON</button>
                </div>
                
                <!-- Color Selector -->
                <div class="tool-group color-selector" id="color-selector">
                    <span class="tool-group-label">üé® Color</span>
                    <div class="current-color-display" id="current-color"></div>
                    <div class="color-palette">
                        <div class="color-option pixelated" data-color="#ffccd2" style="background-color: #ffccd2;" title="Light Red"></div>
                        <div class="color-option pixelated" data-color="#e8f5e8" style="background-color: #e8f5e8;" title="Light Green"></div>
                        <div class="color-option active pixelated" data-color="#f0f8ff" style="background-color: #f0f8ff;" title="Light Blue"></div>
                        <div class="color-option pixelated" data-color="#f3e5f5" style="background-color: #f3e5f5;" title="Light Purple"></div>
                        <div class="color-option pixelated" data-color="#fff3e0" style="background-color: #fff3e0;" title="Light Orange"></div>
                        <div class="color-option pixelated" data-color="#f5f5f5" style="background-color: #f5f5f5;" title="Light Gray"></div>
                        <div class="color-option pixelated" data-color="#fff9c4" style="background-color: #fff9c4;" title="Light Yellow"></div>
                        <div class="color-option pixelated" data-color="#fdfdfd" style="background-color: #fdfdfd;" title="White"></div>
                        <div class="color-option pixelated" data-color="#0d0d0d" style="background-color: #0d0d0d;" title="Black"></div>
                    </div>
                </div>
                
                <!-- Editing Controls -->
                <div class="tool-group">
                    <span class="tool-group-label">üóëÔ∏è Edit</span>
                    <button onclick="deleteSelected()" class="tool-btn delete" id="delete-btn" disabled="">Delete Selected</button>
                    <button onclick="clearCanvas()" class="tool-btn">Clear All</button>
                </div>
            </div>
            
            <!-- Row 2: Editing, File, and Colors -->
            <div class="toolbar-row">
                 <!-- Shape Controls -->
                <div class="tool-group">
                    <span class="tool-group-label">üß± Shapes</span>
                    <button onclick="setMode('ellipse')" class="tool-btn">Oval</button>
                    <button onclick="setMode('hexagon')" class="tool-btn">Preparation</button>
                    <button onclick="setMode('parallelogram')" class="tool-btn">Input/Output</button>
                    <button onclick="setMode('diamond')" class="tool-btn">Decision</button>
                    <button onclick="setMode('rectangle')" class="tool-btn">Process</button>
                    <button onclick="setMode('circle')" class="tool-btn">Connector</button>
                </div>
                
                
                <!-- AI Generator -->
                <div class="ai-generator">
                    <input type="text" class="ai-input" id="ai-input" placeholder="Describe your flowchart idea (e.g., 'Create a flowchart for coffee making process')">
                    <button id="ai-generate-btn" class="ai-generate-btn">
                        <span id="ai-btn-text">üïã Generate Flowchart</span>
                        <span id="ai-loading-spinner" class="loading-spinner" style="display: none;"></span>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="canvas-container" id="canvas-container">
            <div class="canvas-wrapper" id="canvas-wrapper">
                <svg id="canvas" width="100%" height="100%">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#333"></polygon>
                        </marker>
                    </defs>
                </svg>
            </div>
            
        </div>
        
        <div class="status-bar">
            <span id="status-text">üåü Ready - Create amazing flowcharts with Minecraft style! üåü</span>
            <div class="canvas-controls">
                <span id="canvas-position">Position: 0, 0</span>
            </div>
        </div>
    </div>
    
    <!-- AI Generation Modal -->
    <div class="ai-modal" id="ai-modal">
        <div class="ai-modal-content">
            <div class="ai-modal-header">
                <h3 class="ai-modal-title">ü§ñ AI Flowchart Generation</h3>
                <button class="ai-modal-close" onclick="closeAIModal()">√ó</button>
            </div>
            <div class="ai-modal-message" id="ai-modal-message">
                Generating your flowchart...
            </div>
            <div class="ai-modal-actions">
                <button class="ai-modal-btn ai-secondary-btn" onclick="closeAIModal()">Cancel</button>
                <button class="ai-modal-btn ai-primary-btn" id="ai-apply-btn" onclick="applyAIFlowchart()">Apply Flowchart</button>
            </div>
        </div>
    </div>

    <script>
        // Find and update existing arrowhead or create a new one
        function generateOrthogonalPath(x1, y1, x2, y2) {
            // Calculate the midpoint for the bend
            const midX = (x1 + x2) / 2;
            
            // Create a path with horizontal and vertical segments
            if (Math.abs(x2 - x1) > Math.abs(y2 - y1)) {
                // Horizontal-first routing
                return `M${x1},${y1} L${midX},${y1} L${midX},${y2} L${x2},${y2}`;
            } else {
                // Vertical-first routing  
                const midY = (y1 + y2) / 2;
                return `M${x1},${y1} L${x1},${midY} L${x2},${midY} L${x2},${y2}`;
            }
        }


// Global variables
        let currentMode = 'select';
        let shapes = [];
        let arrows = [];
        let freeTexts = [];
        let nextId = 1;
        let dragData = null;
        let resizeData = null;
        let arrowDragData = null;
        let selectedElement = null;
        let arrowStart = null;
        let currentColor = '#f0f8ff';
        let generatedFlowchartData = null;
        
        // Canvas panning variables
        let canvasTransform = {
            x: 0,
            y: 0,
            scale: 1
        };
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;

        // Get canvas element
        const canvas = document.getElementById('canvas');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvasContainer = document.getElementById('canvas-container');
        const deleteBtn = document.getElementById('delete-btn');
        const statusText = document.getElementById('status-text');
        const colorSelector = document.getElementById('color-selector');
        const currentColorDisplay = document.getElementById('current-color');
        const aiInput = document.getElementById('ai-input');
        const aiGenerateBtn = document.getElementById('ai-generate-btn');
        const aiLoadingSpinner = document.getElementById('ai-loading-spinner');
        const aiBtnText = document.getElementById('ai-btn-text');
        const aiModal = document.getElementById('ai-modal');
        const aiModalMessage = document.getElementById('ai-modal-message');
        const aiApplyBtn = document.getElementById('ai-apply-btn');
        const zoomLevelEl = document.getElementById('zoom-level');
        const canvasPositionEl = document.getElementById('canvas-position');

        // Connection point positions for different shapes
        const connectionPoints = {
            rectangle: [
                { x: 0.5, y: 0, id: 'top' },
                { x: 1, y: 0.5, id: 'right' },
                { x: 0.5, y: 1, id: 'bottom' },
                { x: 0, y: 0.5, id: 'left' }
            ],
            ellipse: [
                { x: 0.5, y: 0, id: 'top' },
                { x: 1, y: 0.5, id: 'right' },
                { x: 0.5, y: 1, id: 'bottom' },
                { x: 0, y: 0.5, id: 'left' }
            ],
            diamond: [
                { x: 0.5, y: 0, id: 'top' },
                { x: 1, y: 0.5, id: 'right' },
                { x: 0.5, y: 1, id: 'bottom' },
                { x: 0, y: 0.5, id: 'left' }
            ],
            parallelogram: [
                { x: 0.6, y: 0, id: 'top' },
                { x: 0.9, y: 0.5, id: 'right' },
                { x: 0.4, y: 1, id: 'bottom' },
                { x: 0.1, y: 0.5, id: 'left' }
            ],
            hexagon: [
                { x: 0.5, y: 0, id: 'top' },
                { x: 1, y: 0.5, id: 'right' },
                { x: 0.5, y: 1, id: 'bottom' },
                { x: 0, y: 0.5, id: 'left' }
            ],
            cylinder: [
                { x: 0.5, y: 0.15, id: 'top' },
                { x: 1, y: 0.5, id: 'right' },
                { x: 0.5, y: 0.85, id: 'bottom' },
                { x: 0, y: 0.5, id: 'left' }
            ],
            circle: [
                { x: 0.5, y: 0, id: 'top' },
                { x: 1, y: 0.5, id: 'right' },
                { x: 0.5, y: 1, id: 'bottom' },
                { x: 0, y: 0.5, id: 'left' }
            ]
        };

        // Canvas Panning and Zooming Functions
        function updateCanvasTransform() {
            canvasWrapper.style.transform = `translate(${canvasTransform.x}px, ${canvasTransform.y}px) scale(${canvasTransform.scale})`;
            zoomLevelEl.textContent = `${Math.round(canvasTransform.scale * 100)}%`;
            canvasPositionEl.textContent = `Position: ${Math.round(canvasTransform.x)}, ${Math.round(canvasTransform.y)}`;
            
        }
        
        function startPanning(event) {
            if (currentMode === 'pan' || (currentMode === 'select' && event.target === canvas)) {
                isPanning = true;
                canvas.classList.add('panning');
                
                // Store the initial mouse position
                panStartX = event.clientX - canvasTransform.x;
                panStartY = event.clientY - canvasTransform.y;
                
                // Prevent default behavior
                event.preventDefault();
            }
        }
        
        function pan(event) {
            if (!isPanning) return;
            
            // Calculate new position
            canvasTransform.x = event.clientX - panStartX;
            canvasTransform.y = event.clientY - panStartY;
            
            // Apply the transform
            updateCanvasTransform();
        }
        
        function stopPanning() {
            if (isPanning) {
                isPanning = false;
                canvas.classList.remove('panning');
            }
        }
        
        function zoomIn() {
            canvasTransform.scale = Math.min(3, canvasTransform.scale + 0.1);
            updateCanvasTransform();
            updateStatus(`üîç Zoomed in to ${Math.round(canvasTransform.scale * 100)}%`);
        }
        
        function zoomOut() {
            canvasTransform.scale = Math.max(0.3, canvasTransform.scale - 0.1);
            updateCanvasTransform();
            updateStatus(`üîç Zoomed out to ${Math.round(canvasTransform.scale * 100)}%`);
        }
        
        function resetZoom() {
            canvasTransform.x = 0;
            canvasTransform.y = 0;
            canvasTransform.scale = 1;
            updateCanvasTransform();
            updateStatus('üîÑ View reset to center');
        }
        
        function handleWheel(event) {
            if (event.ctrlKey || event.metaKey) {
                // Prevent the default zoom behavior
                event.preventDefault();
                
                // Calculate zoom
                const zoomDelta = -Math.sign(event.deltaY) * 0.1;
                const newScale = Math.max(0.3, Math.min(3, canvasTransform.scale + zoomDelta));
                
                if (newScale !== canvasTransform.scale) {
                    // Get mouse position relative to canvas
                    const rect = canvasContainer.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    const mouseY = event.clientY - rect.top;
                    
                    // Calculate current position in canvas space
                    const currentPosX = (mouseX - canvasTransform.x) / canvasTransform.scale;
                    const currentPosY = (mouseY - canvasTransform.y) / canvasTransform.scale;
                    
                    // Calculate new position
                    const newPosX = currentPosX * newScale;
                    const newPosY = currentPosY * newScale;
                    
                    // Update transform with zoom centered on mouse position
                    canvasTransform.x += mouseX - canvasTransform.x - newPosX;
                    canvasTransform.y += mouseY - canvasTransform.y - newPosY;
                    canvasTransform.scale = newScale;
                    
                    updateCanvasTransform();
                }
            }
        }
        
        // AI Flowchart Generation
        aiGenerateBtn.addEventListener('click', generateAIFlowchart);

        async function generateAIFlowchart() {
            const userInput = aiInput.value.trim();
            
            if (!userInput) {
                updateStatus('‚ùå Please enter a description for your flowchart');
                return;
            }
            
            // Show loading state
            setAILoadingState(true);
            updateStatus('ü§ñ Generating flowchart from your description...');
            
            // Create a well-structured prompt for the LLM
            const prompt = createFlowchartPrompt(userInput);
            
            try {
                // Call Pollinations.ai API
                const response = await fetch(`https://text.pollinations.ai/${encodeURIComponent(prompt)}`);
                const textResponse = await response.text();
                
                // Process the response and extract JSON
                const extractedData = extractJSONFromResponse(textResponse);
                
                if (extractedData) {
                    // Show success in modal
                    showAIModal('success', extractedData);
                    generatedFlowchartData = extractedData;
                    updateStatus('üéâ Flowchart generated successfully! Review and apply it.');
                } else {
                    // Show error in modal
                    showAIModal('error', textResponse);
                    updateStatus('‚ùå Could not parse the generated flowchart. See details in the modal.');
                }
            } catch (error) {
                console.error('Error generating flowchart:', error);
                showAIModal('error', `Error: ${error.message}`);
                updateStatus('‚ùå Error connecting to AI service. Please try again.');
            } finally {
                setAILoadingState(false);
            }
        }

        function createFlowchartPrompt(userInput) {
            return `Create a detailed flowchart based on the TASK DESCRIPTION.

Format your response as a valid JSON object with two arrays:

---

**"shapes"**: An array of shape objects, each with:

- "id": unique integer ID (start from 1)
- "type": one of "rectangle", "ellipse", "diamond", "parallelogram", "hexagon", "cylinder", or "circle"
- "x": x-coordinate (integer between 50‚Äì700)
- "y": y-coordinate (integer between 50‚Äì700)
- "width": 100‚Äì130 (recommended range)
- "height": 50‚Äì80 (recommended range)
- "text": text label for the shape
- "color": one of: "#f0f8ff", "#e1f5fe", "#f3e5f5", "#e8f5e8", "#fff3e0", "#ffebee", "#f5f5f5", "#fff9c4", "#ffffff"

---

**"arrows"**: An array of arrow objects, each with:

- "id": unique integer ID (continuing from shapes)
- "startId": ID of source shape
- "startPoint": one of "top", "right", "bottom", "left"
- "endId": ID of target shape
- "endPoint": one of "top", "right", "bottom", "left"
- "color": hex code (usually "#333333")

---

üß≠ VISUAL DESIGN RULES

1. **Left-to-Right Alignment (Preferred)**
   - Organize flow from **left to right** to better use horizontal space.
   - Each "stage" in the process should form a vertical column, spaced horizontally.
   - Place sequential steps at the **same y-coordinate** but increasing x-coordinates.
   - Use vertical stacking only for subtasks or branches.

2. **Spacing Guidelines**
   - Maintain at least **150px horizontal spacing** between columns.
   - Leave at least **80px vertical spacing** between shapes in the same column.
   - No overlapping shapes.

3. **Logical Shape Usage**
   - Use:
     - "ellipse" for Start/End
     - "rectangle" for general steps
     - "diamond" for decisions/conditions

4. **Branching and Merging**
   - For decisions, branch left and right from a "diamond" using "left" and "right" connection points.
   - Merge back later using arrows from "bottom" or "top" into a common step.

5. **Arrow Clarity**
   - Use "right" for forward flow, "left" for backward flow, and vertical points for substeps.
   - Avoid arrow overlap or backtracking whenever possible.

6. **Label Clarity**
   - Keep text clear and concise (~30 characters max).
   - Break long process names into smaller blocks when needed.

---

TASK DESCRIPTION:
Provide a complete, valid JSON flowchart representing: "${userInput}";`
        }

        function extractJSONFromResponse(text) {
            try {
                // Try to parse the entire response as JSON first
                return JSON.parse(text);
            } catch (e) {
                // If that fails, look for JSON object pattern in the text
                const jsonPattern = /\{[\s\S]*\}/;
                const match = text.match(jsonPattern);
                
                if (match) {
                    try {
                        return JSON.parse(match[0]);
                    } catch (err) {
                        console.error('Error parsing extracted JSON:', err);
                        return null;
                    }
                }
                
                return null;
            }
        }

        function setAILoadingState(isLoading) {
            if (isLoading) {
                aiLoadingSpinner.style.display = 'inline-block';
                aiBtnText.textContent = 'Generating...';
                aiGenerateBtn.disabled = true;
            } else {
                aiLoadingSpinner.style.display = 'none';
                aiBtnText.textContent = 'ü§ñ Generate Flowchart';
                aiGenerateBtn.disabled = false;
            }
        }

        function showAIModal(type, data) {
            aiModal.classList.add('active');
            
            if (type === 'success') {
                // Preview of what will be created
                const shapeCount = data.shapes ? data.shapes.length : 0;
                const arrowCount = data.arrows ? data.arrows.length : 0;
                
                aiModalMessage.classList.remove('ai-error');
                aiModalMessage.innerHTML = `
                    <p>‚úÖ Successfully generated a flowchart with:</p>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li>${shapeCount} shapes</li>
                        <li>${arrowCount} connecting arrows</li>
                    </ul>
                    <p style="margin-top: 10px;">Ready to apply this flowchart to your canvas?</p>
                `;
                aiApplyBtn.style.display = 'block';
            } else {
                // Error message
                aiModalMessage.classList.add('ai-error');
                aiModalMessage.innerHTML = `
                    <p>‚ùå There was a problem generating your flowchart:</p>
                    <p style="margin-top: 10px; font-size: 12px; max-height: 200px; overflow-y: auto;">
                        ${data}
                    </p>
                    <p style="margin-top: 10px;">Please try again with a more specific description.</p>
                `;
                aiApplyBtn.style.display = 'none';
            }
        }

        function closeAIModal() {
            aiModal.classList.remove('active');
        }

        function applyAIFlowchart() {
            if (!generatedFlowchartData) {
                updateStatus('‚ùå No flowchart data to apply');
                return;
            }
            
            // Clear current canvas
            clearCanvas();
            
            // Apply the data
            loadData(generatedFlowchartData);
            
            // Reset the view to show the entire flowchart
            centerViewOnFlowchart();
            
            // Close modal
            closeAIModal();
            
            // Update status
            updateStatus('üéâ AI-generated flowchart applied successfully!');
        }
        
        function centerViewOnFlowchart() {
            if (shapes.length === 0) {
                resetZoom();
                return;
            }
            
            // Find the bounds of all shapes
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            shapes.forEach(shape => {
                minX = Math.min(minX, shape.x);
                minY = Math.min(minY, shape.y);
                maxX = Math.max(maxX, shape.x + shape.width);
                maxY = Math.max(maxY, shape.y + shape.height);
            });
            
            // Add padding
            const padding = 50;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;
            
            // Calculate center of the flowchart
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            // Calculate container center
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;
            
            // Calculate scale to fit the flowchart
            const flowchartWidth = maxX - minX;
            const flowchartHeight = maxY - minY;
            const scaleX = containerWidth / flowchartWidth;
            const scaleY = containerHeight / flowchartHeight;
            let scale = Math.min(scaleX, scaleY, 1); // Don't zoom in more than 100%
            
            // Update transform
            canvasTransform.x = containerWidth / 2 - centerX * scale;
            canvasTransform.y = containerHeight / 2 - centerY * scale;
            canvasTransform.scale = scale;
            
            updateCanvasTransform();
            
        }

        // Color selection setup
        function setupColorSelection() {
            const colorOptions = document.querySelectorAll('.color-option');
            
            colorOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const color = this.getAttribute('data-color');
                    selectColor(color);
                });
            });
            
            updateColorDisplay();
            updateColorSelectorState();
        }

        function selectColor(color) {
            currentColor = color;
            
            // Update active color option
            document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('active'));
            document.querySelector(`[data-color="${color}"]`).classList.add('active');
            
            updateColorDisplay();
            
            // Apply color to selected element
            if (selectedElement) {
                applyColorToSelected(color);
            }
        }

        function updateColorDisplay() {
            currentColorDisplay.style.backgroundColor = currentColor;
        }

        function updateColorSelectorState() {
            if (selectedElement) {
                colorSelector.classList.remove('disabled');
            } else {
                colorSelector.classList.add('disabled');
            }
        }

        function applyColorToSelected(color) {
            if (!selectedElement) return;
            
            if (selectedElement.type === 'shape') {
                const shape = shapes.find(s => s.id === selectedElement.id);
                if (shape) {
                    shape.color = color;
                    const shapeElement = document.querySelector(`.shape[data-id="${shape.id}"]`);
                    if (shapeElement) {
                        shapeElement.style.fill = color;
                    }
                    updateStatus(`üé® Shape color changed to ${getColorName(color)}`);
                }
            } else if (selectedElement.type === 'arrow') {
                const arrow = arrows.find(a => a.id === selectedElement.id);
                if (arrow) {
                    arrow.color = color;
                    const arrowElement = document.querySelector(`.arrow[data-id="${arrow.id}"]`);
                    if (arrowElement) {
                        arrowElement.style.stroke = color;
                    }
                    // Update arrowhead color
                    updateArrowheadColor(arrow.id, color);
                    updateStatus(`üé® Arrow color changed to ${getColorName(color)}`);
                }
            } else if (selectedElement.type === 'text') {
                const text = freeTexts.find(t => t.id === selectedElement.id);
                if (text) {
                    text.color = color;
                    const textElement = document.querySelector(`.free-text[data-id="${text.id}"]`);
                    if (textElement) {
                        textElement.style.fill = color;
                    }
                    updateStatus(`üé® Text color changed to ${getColorName(color)}`);
                }
            }
        }

        function getColorName(color) {
            const colorNames = {
                '#f0f8ff': 'Light Blue',
                '#e1f5fe': 'Sky Blue',
                '#f3e5f5': 'Light Purple',
                '#e8f5e8': 'Light Green',
                '#fff3e0': 'Light Orange',
                '#ffebee': 'Light Pink',
                '#f5f5f5': 'Light Gray',
                '#fff9c4': 'Light Yellow',
                '#ffffff': 'White'
            };
            return colorNames[color] || color;
        }

        function updateArrowheadColor(arrowId, color) {
            // Create a unique arrowhead marker for this color
            const defs = canvas.querySelector('defs');
            let marker = defs.querySelector(`#arrowhead-${arrowId}`);
            
            if (!marker) {
                marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', `arrowhead-${arrowId}`);
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '7');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3.5');
                marker.setAttribute('orient', 'auto');
                
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                marker.appendChild(polygon);
                
                defs.appendChild(marker);
            }
            
            const polygon = marker.querySelector('polygon');
            polygon.setAttribute('fill', color);
            
            const arrowElement = document.querySelector(`.arrow[data-id="${arrowId}"]`);
            if (arrowElement) {
                arrowElement.style.markerEnd = `url(#arrowhead-${arrowId})`;
            }
        }

        // Status updates with Minecraft emojis
        function updateStatus(message) {
            statusText.textContent = message;
        }

        function updateSelectionStatus() {
            if (!selectedElement) {
                updateStatus('üåü Ready - Select shapes, arrows, or text to change their colors! üåü');
                return;
            }
            
            if (selectedElement.type === 'shape') {
                const shape = shapes.find(s => s.id === selectedElement.id);
                updateStatus(`üß± Shape selected: ${shape.type} - "${shape.text}" | Change color or press Delete to remove`);
            } else if (selectedElement.type === 'arrow') {
                updateStatus('üèπ Arrow selected | Change color, drag yellow endpoints to reconnect, or press Delete to remove');
            } else if (selectedElement.type === 'text') {
                const text = freeTexts.find(t => t.id === selectedElement.id);
                updateStatus(`üìù Text selected: "${text.text}" | Change color, drag to move, or press Delete to remove`);
            }
        }

        // Mode management
        function setMode(mode) {
            console.log('Setting mode to:', mode);
            currentMode = mode;
            
            // Update button states
            document.querySelectorAll('.tool-btn:not(.delete)').forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // Update cursor and connection points visibility
            if (mode === 'select') {
                canvas.classList.add('select-mode');
                canvas.classList.remove('pan-mode');
                updateConnectionPointsVisibility();
                updateStatus('‚öîÔ∏è Select mode - Click shapes, arrows, or text to select them');
            } else if (mode === 'pan') {
                canvas.classList.remove('select-mode');
                canvas.classList.add('pan-mode');
                hideAllConnectionPoints();
                clearSelection();
                updateStatus('‚úã Pan mode - Drag the canvas to move around your flowchart');
            } else {
                canvas.classList.remove('select-mode');
                canvas.classList.remove('pan-mode');
                if (mode === 'arrow') {
                    showAllConnectionPoints();
                    updateStatus('üèπ Arrow mode - Click orange connection points to create arrows between shapes');
                } else if (mode === 'text') {
                    hideAllConnectionPoints();
                    updateStatus('üìù Free Text mode - Click anywhere to add text');
                } else {
                    hideAllConnectionPoints();
                    updateStatus(`üß± ${mode} mode - Click on canvas to create ${mode} shapes`);
                }
            }
            
            // Clear selection and arrow start
            clearSelection();
            arrowStart = null;
        }

        function updateConnectionPointsVisibility() {
            document.querySelectorAll('.connection-points').forEach(points => {
                points.classList.remove('arrow-mode');
            });
        }

        function showAllConnectionPoints() {
            document.querySelectorAll('.connection-points').forEach(points => {
                points.classList.add('arrow-mode');
            });
        }

        function hideAllConnectionPoints() {
            document.querySelectorAll('.connection-points').forEach(points => {
                points.classList.remove('arrow-mode');
            });
        }

        // Auto-switch to select mode when shape is created
        function autoSwitchToSelect() {
            setMode('select');
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[onclick="setMode(\'select\')"]').classList.add('active');
        }

        // Canvas click handler
        canvas.addEventListener('click', function(e) {
            // Don't handle clicks when panning
            if (isPanning) return;
            
            // Handle connection point clicks
            if (e.target.classList.contains('connection-point')) {
                handleConnectionPointClick(e.target);
                return;
            }

            // Don't handle clicks on resize handles or arrow endpoints
            if (e.target.classList.contains('resize-handle') || e.target.classList.contains('arrow-endpoint')) {
                return;
            }
            
            // In pan mode, don't create shapes
            if (currentMode === 'pan') {
                return;
            }

            const rect = canvasContainer.getBoundingClientRect();
            // Adjust coordinates based on canvas transform
            const x = (e.clientX - rect.left - canvasTransform.x) / canvasTransform.scale;
            const y = (e.clientY - rect.top - canvasTransform.y) / canvasTransform.scale;
            
            if (currentMode === 'rectangle' || currentMode === 'ellipse' || 
                currentMode === 'diamond' || currentMode === 'parallelogram' ||
                currentMode === 'hexagon' || currentMode === 'cylinder' || 
                currentMode === 'circle') {
                createShape(currentMode, x, y);
                autoSwitchToSelect();
            } else if (currentMode === 'text') {
                createFreeText(x, y);
                autoSwitchToSelect();
            } else if (currentMode === 'select') {
                handleSelect(e.target);
            }
        });

        function handleConnectionPointClick(target) {
            const shapeId = parseInt(target.getAttribute('data-shape-id'));
            const pointId = target.getAttribute('data-point-id');
            const shape = shapes.find(s => s.id === shapeId);
            
            if (currentMode === 'arrow') {
                if (!arrowStart) {
                    arrowStart = { shape, pointId };
                    updateStatus(`üèπ Arrow start selected on ${shape.type} - Click another connection point to finish arrow`);
                    console.log('Arrow start:', shape.id, pointId);
                } else if (arrowStart.shape.id !== shape.id) {
                    createArrow(arrowStart.shape, arrowStart.pointId, shape, pointId);
                    autoSwitchToSelect();
                    updateStatus('üèπ Arrow created! Click connection points to create more arrows');
                    arrowStart = null;
                }
            }
        }

        function createFreeText(x, y) {
            selectColor('#0d0d0d');
            const text = {
                id: nextId++,
                x: x,
                y: y,
                text: 'New Text',
                color: currentColor
            };
            
            freeTexts.push(text);
            renderFreeText(text);
            
            setTimeout(() => {
                selectText(text.id);
                editFreeText(text);
            }, 10);
        }

        function renderFreeText(text) {
            const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textElement.setAttribute('x', text.x);
            textElement.setAttribute('y', text.y);
            textElement.classList.add('free-text');
            textElement.textContent = text.text;
            textElement.setAttribute('data-id', text.id);
            textElement.style.fill = text.color || currentColor;
            
            canvas.appendChild(textElement);
            
            // Add double-click for text editing
            textElement.addEventListener('dblclick', () => editFreeText(text));
        }

        function editFreeText(text) {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = text.text;
            input.className = 'text-input';
            
            // Calculate position considering canvas transform
            const rect = canvasContainer.getBoundingClientRect();
            const posX = text.x * canvasTransform.scale + canvasTransform.x + rect.left;
            const posY = text.y * canvasTransform.scale + canvasTransform.y + rect.top;
            
            input.style.left = (posX - 50) + 'px';
            input.style.top = (posY - 10) + 'px';
            input.style.width = '360px';
            
            document.body.appendChild(input);
            input.focus();
            input.select();
            
            function finishEdit() {
                text.text = input.value || 'Text';
                const textElement = document.querySelector(`.free-text[data-id="${text.id}"]`);
                if (textElement) {
                    textElement.textContent = text.text;
                }
                document.body.removeChild(input);
                updateSelectionStatus();
            }
            
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') finishEdit();
            });
        }

        function createShape(type, x, y) {
            console.log('Creating shape:', type);
            selectColor('#fdfdfd');
            
            let width = 100, height = 50;
            if (type === 'diamond') {
                width = 120;
                height = 60;
            } else if (type === 'circle') {
                width = 60;
                height = 60;
            } else if (type === 'cylinder') {
                width = 100;
                height = 70;
            }
            
            const shape = {
                id: nextId++,
                type: type,
                x: x - width/2,
                y: y - height/2,
                width: width,
                height: height,
                text: getDefaultText(type),
                color: currentColor
            };
            
            shapes.push(shape);
            renderShape(shape);
            
            setTimeout(() => {
                selectShape(shape.id);
            }, 10);
        }

        function getDefaultText(type) {
            const textMap = {
                'rectangle': 'Process',
                'ellipse': 'Start/End',
                'diamond': 'Decision?',
                'parallelogram': 'Input/Output',
                'hexagon': 'Preparation',
                'cylinder': 'Database',
                'circle': 'Connector'
            };
            return textMap[type] || 'Text';
        }

        function updateMultiLineText(textElement, text, x, y) {
            // Clear existing content
            textElement.innerHTML = '';
            
            const lines = text.split('\n');
            const lineHeight = 16; // Adjust based on font size
            const totalHeight = lines.length * lineHeight;
            const startY = y - (totalHeight / 2) + (lineHeight / 2);
            
            lines.forEach((line, index) => {
                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                tspan.textContent = line;
                tspan.setAttribute('x', x);
                tspan.setAttribute('y', startY + (index * lineHeight));
                textElement.appendChild(tspan);
            });
        }

        function renderShape(shape) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('data-id', shape.id);
            group.classList.add('shape-group');
            
            let shapeElement = createShapeElement(shape);
            shapeElement.classList.add('shape');
            shapeElement.setAttribute('data-id', shape.id);
            shapeElement.style.fill = shape.color || currentColor;
            
            const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textElement.setAttribute('data-id', shape.id);
            textElement.setAttribute('x', shape.x + shape.width / 2);
            textElement.setAttribute('y', shape.y + shape.height / 2);
            textElement.classList.add('shape-text');
            textElement.setAttribute('data-id', shape.id);

            // Use the multi-line text function
            updateMultiLineText(textElement, shape.text, shape.x + shape.width / 2, shape.y + shape.height / 2);
            
            // Create resize handles and connection points
            const resizeHandles = createResizeHandles(shape);
            const connectionPointsGroup = createConnectionPoints(shape);
            
            group.appendChild(shapeElement);
            group.appendChild(textElement);
            group.appendChild(resizeHandles);
            group.appendChild(connectionPointsGroup);
            canvas.appendChild(group);
            
            // Add double-click for text editing
            shapeElement.addEventListener('dblclick', () => editText(shape, textElement));
            textElement.addEventListener('dblclick', () => editText(shape, textElement));
        }

        function createConnectionPoints(shape) {
            const pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pointsGroup.classList.add('connection-points');
            
            const points = connectionPoints[shape.type] || connectionPoints.rectangle;
            
            points.forEach(point => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                const absoluteX = shape.x + point.x * shape.width;
                const absoluteY = shape.y + point.y * shape.height;
                
                circle.setAttribute('cx', absoluteX);
                circle.setAttribute('cy', absoluteY);
                circle.setAttribute('r', 5);
                circle.classList.add('connection-point');
                circle.setAttribute('data-shape-id', shape.id);
                circle.setAttribute('data-point-id', point.id);
                
                pointsGroup.appendChild(circle);
            });
            
            return pointsGroup;
        }

        function updateConnectionPoints(shape) {
            const group = document.querySelector(`g[data-id="${shape.id}"]`);
            const pointsGroup = group.querySelector('.connection-points');
            
            if (!pointsGroup) return;
            
            const points = connectionPoints[shape.type] || connectionPoints.rectangle;
            const circles = pointsGroup.querySelectorAll('.connection-point');
            
            circles.forEach((circle, index) => {
                if (points[index]) {
                    const absoluteX = shape.x + points[index].x * shape.width;
                    const absoluteY = shape.y + points[index].y * shape.height;
                    circle.setAttribute('cx', absoluteX);
                    circle.setAttribute('cy', absoluteY);
                }
            });
        }

        function createArrow(startShape, startPointId, endShape, endPointId) {
            const arrow = {
                id: nextId++,
                startId: startShape.id,
                startPoint: startPointId,
                endId: endShape.id,
                endPoint: endPointId,
                color: '#333333'
            };
            
            arrows.push(arrow);
            renderArrow(arrow);
            
            setTimeout(() => {
                selectArrow(arrow.id);
            }, 10);
        }

        function calculateArrowOffsets(startPos, endPos, startPoint, endPoint, offsetDistance = 20) {
            let startOffsetX = startPos.x;
            let startOffsetY = startPos.y;
            
            switch (startPoint) {
                case 'top':
                    startOffsetY -= offsetDistance;
                    break;
                case 'bottom':
                    startOffsetY += offsetDistance;
                    break;
                case 'left':
                    startOffsetX -= offsetDistance;
                    break;
                case 'right':
                    startOffsetX += offsetDistance;
                    break;
            }
            
            let endOffsetX = endPos.x;
            let endOffsetY = endPos.y;
            
            switch (endPoint) {
                case 'top':
                    endOffsetY -= offsetDistance;
                    break;
                case 'bottom':
                    endOffsetY += offsetDistance;
                    break;
                case 'left':
                    endOffsetX -= offsetDistance;
                    break;
                case 'right':
                    endOffsetX += offsetDistance;
                    break;
            }
            
            return {
                startOffset: { x: startOffsetX, y: startOffsetY },
                endOffset: { x: endOffsetX, y: endOffsetY }
            };
        }

        function generateCompleteArrowPath(startPos, endPos, startPoint, endPoint, offsetDistance = 20) {
            const offsets = calculateArrowOffsets(startPos, endPos, startPoint, endPoint, offsetDistance);
            
            // Start with connection point
            let pathData = `M ${startPos.x} ${startPos.y}`;
            
            // Line to start offset point
            pathData += ` L ${offsets.startOffset.x} ${offsets.startOffset.y}`;
            
            // Generate orthogonal path between offset points
            const orthogonalPath = generateOrthogonalPath(
                offsets.startOffset.x, 
                offsets.startOffset.y, 
                offsets.endOffset.x, 
                offsets.endOffset.y
            );
            
            // Extract the path commands after the initial M command
            const orthogonalCommands = orthogonalPath.substring(orthogonalPath.indexOf(' '));
            pathData += orthogonalCommands;
            
            // Line from end offset point to connection point
            pathData += ` L ${endPos.x} ${endPos.y}`;
            
            return pathData;
        }

        function renderArrow(arrow) {
            const startShape = shapes.find(s => s.id === arrow.startId);
            const endShape = shapes.find(s => s.id === arrow.endId);
            
            if (!startShape || !endShape) return;
            
            const startPos = getConnectionPointPosition(startShape, arrow.startPoint);
            const endPos = getConnectionPointPosition(endShape, arrow.endPoint);
            
            // Create arrow group
            const arrowGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            arrowGroup.classList.add('arrow-group');
            arrowGroup.setAttribute('data-id', arrow.id);
            
            // Create orthogonal path
            const pathData = generateCompleteArrowPath(startPos, endPos, arrow.startPoint, arrow.endPoint);
            
            // Create invisible selection area (wider path for easier clicking)
            const selectionArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            selectionArea.setAttribute('d', pathData);
            selectionArea.classList.add('arrow-selection-area');
            selectionArea.setAttribute('data-id', arrow.id);
            selectionArea.style.strokeWidth = '15';
            selectionArea.style.stroke = 'transparent';
            selectionArea.style.fill = 'none';
            
            // Create visible arrow path
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arrowPath.setAttribute('d', pathData);
            arrowPath.classList.add('arrow');
            arrowPath.setAttribute('data-id', arrow.id);
            arrowPath.style.stroke = arrow.color || '#333333';
            arrowPath.style.strokeWidth = '2';
            arrowPath.style.fill = 'none';
            arrowPath.style.markerEnd = 'url(#arrowhead)';
            
            // Create arrow endpoints for editing
            const endpoints = createArrowEndpoints(arrow, startPos, endPos);
            
            arrowGroup.appendChild(selectionArea);
            arrowGroup.appendChild(arrowPath);
            arrowGroup.appendChild(endpoints);
            canvas.appendChild(arrowGroup);
            
            // Set up custom arrowhead color
            if (arrow.color && arrow.color !== '#333333') {
                updateArrowheadColor(arrow.id, arrow.color);
            }
        }

        function createArrowEndpoints(arrow, startPos, endPos) {
            const endpointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            endpointsGroup.classList.add('arrow-endpoints');
            
            // Start endpoint
            const startEndpoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            startEndpoint.setAttribute('cx', startPos.x);
            startEndpoint.setAttribute('cy', startPos.y);
            startEndpoint.setAttribute('r', 6);
            startEndpoint.classList.add('arrow-endpoint');
            startEndpoint.setAttribute('data-arrow-id', arrow.id);
            startEndpoint.setAttribute('data-endpoint', 'start');
            
            // End endpoint
            const endEndpoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            endEndpoint.setAttribute('cx', endPos.x);
            endEndpoint.setAttribute('cy', endPos.y);
            endEndpoint.setAttribute('r', 6);
            endEndpoint.classList.add('arrow-endpoint');
            endEndpoint.setAttribute('data-arrow-id', arrow.id);
            endEndpoint.setAttribute('data-endpoint', 'end');
            
            endpointsGroup.appendChild(startEndpoint);
            endpointsGroup.appendChild(endEndpoint);
            
            return endpointsGroup;
        }

        function getConnectionPointPosition(shape, pointId) {
            const points = connectionPoints[shape.type] || connectionPoints.rectangle;
            const point = points.find(p => p.id === pointId) || points[0];
            
            return {
                x: shape.x + point.x * shape.width,
                y: shape.y + point.y * shape.height
            };
        }

        function createResizeHandles(shape) {
            const handlesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            handlesGroup.classList.add('resize-handles');
            
            const handles = [
                { x: shape.x, y: shape.y, cursor: 'nw-resize', type: 'nw' },
                { x: shape.x + shape.width/2, y: shape.y, cursor: 'n-resize', type: 'n' },
                { x: shape.x + shape.width, y: shape.y, cursor: 'ne-resize', type: 'ne' },
                { x: shape.x + shape.width, y: shape.y + shape.height/2, cursor: 'e-resize', type: 'e' },
                { x: shape.x + shape.width, y: shape.y + shape.height, cursor: 'se-resize', type: 'se' },
                { x: shape.x + shape.width/2, y: shape.y + shape.height, cursor: 's-resize', type: 's' },
                { x: shape.x, y: shape.y + shape.height, cursor: 'sw-resize', type: 'sw' },
                { x: shape.x, y: shape.y + shape.height/2, cursor: 'w-resize', type: 'w' }
            ];
            
            handles.forEach(handle => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', handle.x);
                circle.setAttribute('cy', handle.y);
                circle.setAttribute('r', 4);
                circle.classList.add('resize-handle');
                circle.style.cursor = handle.cursor;
                circle.setAttribute('data-type', handle.type);
                circle.setAttribute('data-shape-id', shape.id);
                
                handlesGroup.appendChild(circle);
            });
            
            return handlesGroup;
        }

        function createShapeElement(shape) {
            const { type, x, y, width, height } = shape;
            
            switch(type) {
                case 'rectangle':
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', y);
                    rect.setAttribute('width', width);
                    rect.setAttribute('height', height);
                    rect.setAttribute('rx', 5);
                    return rect;
                    
                case 'ellipse':
                    const ellipse = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                    ellipse.setAttribute('cx', x + width / 2);
                    ellipse.setAttribute('cy', y + height / 2);
                    ellipse.setAttribute('rx', width / 2);
                    ellipse.setAttribute('ry', height / 2);
                    return ellipse;
                    
                case 'diamond':
                    const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const points = [
                        `${x + width/2},${y}`,
                        `${x + width},${y + height/2}`,
                        `${x + width/2},${y + height}`,
                        `${x},${y + height/2}`
                    ].join(' ');
                    diamond.setAttribute('points', points);
                    return diamond;
                    
                case 'parallelogram':
                    const para = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const offset = width * 0.2;
                    const paraPoints = [
                        `${x + offset},${y}`,
                        `${x + width},${y}`,
                        `${x + width - offset},${y + height}`,
                        `${x},${y + height}`
                    ].join(' ');
                    para.setAttribute('points', paraPoints);
                    return para;
                    
                case 'hexagon':
                    const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const hexOffset = width * 0.25;
                    const hexPoints = [
                        `${x + hexOffset},${y}`,
                        `${x + width - hexOffset},${y}`,
                        `${x + width},${y + height/2}`,
                        `${x + width - hexOffset},${y + height}`,
                        `${x + hexOffset},${y + height}`,
                        `${x},${y + height/2}`
                    ].join(' ');
                    hex.setAttribute('points', hexPoints);
                    return hex;
                    
                case 'cylinder':
                    const cylGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    
                    const cylRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    cylRect.setAttribute('x', x);
                    cylRect.setAttribute('y', y + height * 0.15);
                    cylRect.setAttribute('width', width);
                    cylRect.setAttribute('height', height * 0.7);
                    
                    const cylTop = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                    cylTop.setAttribute('cx', x + width / 2);
                    cylTop.setAttribute('cy', y + height * 0.15);
                    cylTop.setAttribute('rx', width / 2);
                    cylTop.setAttribute('ry', height * 0.15);
                    
                    const cylBottom = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                    cylBottom.setAttribute('cx', x + width / 2);
                    cylBottom.setAttribute('cy', y + height * 0.85);
                    cylBottom.setAttribute('rx', width / 2);
                    cylBottom.setAttribute('ry', height * 0.15);
                    
                    cylGroup.appendChild(cylRect);
                    cylGroup.appendChild(cylTop);
                    cylGroup.appendChild(cylBottom);
                    return cylGroup;
                    
                case 'circle':
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x + width / 2);
                    circle.setAttribute('cy', y + height / 2);
                    circle.setAttribute('r', Math.min(width, height) / 2);
                    return circle;
                    
                default:
                    return createShapeElement({...shape, type: 'rectangle'});
            }
        }

        function handleSelect(target) {
            clearSelection();
            
            if (target.classList.contains('shape') || target.classList.contains('shape-text')) {
                const id = parseInt(target.getAttribute('data-id'));
                selectShape(id);
            } else if (target.classList.contains('arrow') || target.classList.contains('arrow-selection-area')) {
                const id = parseInt(target.getAttribute('data-id'));
                selectArrow(id);
            } else if (target.classList.contains('free-text')) {
                const id = parseInt(target.getAttribute('data-id'));
                selectText(id);
            }
        }

        function selectShape(id) {
            const group = document.querySelector(`g[data-id="${id}"]`);
            const shape = document.querySelector(`.shape[data-id="${id}"]`);
            if (shape && group) {
                shape.classList.add('selected');
                group.classList.add('selected');
                selectedElement = { type: 'shape', id: id };
                updateDeleteButton();
                updateColorSelectorState();
                updateSelectionStatus();
                
                // Update current color to match selected shape
                const shapeData = shapes.find(s => s.id === id);
                if (shapeData && shapeData.color) {
                    const colorOption = document.querySelector(`[data-color="${shapeData.color}"]`);
                    if (colorOption) {
                        selectColor(shapeData.color);
                    }
                }
            }
        }

        function selectArrow(id) {
            const arrowGroup = document.querySelector(`.arrow-group[data-id="${id}"]`);
            const arrow = document.querySelector(`.arrow[data-id="${id}"]`);
            if (arrow && arrowGroup) {
                arrow.classList.add('selected');
                arrowGroup.classList.add('selected');
                selectedElement = { type: 'arrow', id: id };
                updateDeleteButton();
                updateColorSelectorState();
                updateSelectionStatus();
                
                // Update current color to match selected arrow
                const arrowData = arrows.find(a => a.id === id);
                if (arrowData && arrowData.color) {
                    const colorOption = document.querySelector(`[data-color="${arrowData.color}"]`);
                    if (colorOption) {
                        selectColor(arrowData.color);
                    }
                }
            }
        }

        function selectText(id) {
            const textElement = document.querySelector(`.free-text[data-id="${id}"]`);
            if (textElement) {
                textElement.classList.add('selected');
                selectedElement = { type: 'text', id: id };
                updateDeleteButton();
                updateColorSelectorState();
                updateSelectionStatus();
                
                // Update current color to match selected text
                const textData = freeTexts.find(t => t.id === id);
                if (textData && textData.color) {
                    const colorOption = document.querySelector(`[data-color="${textData.color}"]`);
                    if (colorOption) {
                        selectColor(textData.color);
                    }
                }
            }
        }

        function clearSelection() {
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            selectedElement = null;
            updateDeleteButton();
            updateColorSelectorState();
            updateSelectionStatus();
        }

        function updateDeleteButton() {
            deleteBtn.disabled = !selectedElement;
        }

        function deleteSelected() {
            if (!selectedElement) return;
            
            if (selectedElement.type === 'shape') {
                deleteShape(selectedElement.id);
                updateStatus('üß± Shape deleted');
            } else if (selectedElement.type === 'arrow') {
                deleteArrow(selectedElement.id);
                updateStatus('üèπ Arrow deleted');
            } else if (selectedElement.type === 'text') {
                deleteText(selectedElement.id);
                updateStatus('üìù Text deleted');
            }
        }

        function deleteText(id) {
            freeTexts = freeTexts.filter(t => t.id !== id);
            const textElement = document.querySelector(`.free-text[data-id="${id}"]`);
            if (textElement) textElement.remove();
            clearSelection();
        }

        // Mouse event handlers
        function getCanvasCoordinates(clientX, clientY) {
            const rect = canvasContainer.getBoundingClientRect();
            return {
                x: (clientX - rect.left - canvasTransform.x) / canvasTransform.scale,
                y: (clientY - rect.top - canvasTransform.y) / canvasTransform.scale
            };
        }

        canvasContainer.addEventListener('mousedown', function(e) {
            // Start panning if in pan mode or if holding space key
            if (currentMode === 'pan' || (e.target === canvas && (e.buttons === 4 || e.buttons === 1 && e.altKey))) {
                startPanning(e);
                return;
            }
            
            const target = e.target;
            
            // Handle free text dragging
            if (target.classList.contains('free-text')) {
                const id = parseInt(target.getAttribute('data-id'));
                const text = freeTexts.find(t => t.id === id);
                
                if (text) {
                    const canvasCoords = getCanvasCoordinates(e.clientX, e.clientY);
                    dragData = {
                        text: text,
                        startX: canvasCoords.x - text.x,
                        startY: canvasCoords.y - text.y,
                        type: 'text'
                    };
                    
                    selectText(id);
                    updateStatus('üìù Dragging text...');
                }
                e.preventDefault();
                return;
            }
            
            // Handle arrow endpoint dragging
            if (target.classList.contains('arrow-endpoint')) {
                const arrowId = parseInt(target.getAttribute('data-arrow-id'));
                const endpoint = target.getAttribute('data-endpoint');
                const arrow = arrows.find(a => a.id === arrowId);
                
                if (arrow) {
                    arrowDragData = {
                        arrow: arrow,
                        endpoint: endpoint,
                        originalConnection: endpoint === 'start' ? 
                            { shapeId: arrow.startId, pointId: arrow.startPoint } :
                            { shapeId: arrow.endId, pointId: arrow.endPoint }
                    };
                    
                    // Show all connection points during arrow editing
                    showAllConnectionPoints();
                    updateStatus('üèπ Drag to reconnect arrow endpoint to a different connection point');
                }
                e.preventDefault();
                return;
            }
            
            // Handle resize handle mousedown
            if (target.classList.contains('resize-handle')) {
                const shapeId = parseInt(target.getAttribute('data-shape-id'));
                const handleType = target.getAttribute('data-type');
                const shape = shapes.find(s => s.id === shapeId);
                
                if (shape) {
                    const canvasCoords = getCanvasCoordinates(e.clientX, e.clientY);
                    resizeData = {
                        shape: shape,
                        handleType: handleType,
                        startX: canvasCoords.x,
                        startY: canvasCoords.y,
                        originalX: shape.x,
                        originalY: shape.y,
                        originalWidth: shape.width,
                        originalHeight: shape.height
                    };
                    updateStatus('üß± Resizing shape...');
                }
                e.preventDefault();
                return;
            }
            
            // Handle shape dragging
            if (currentMode !== 'select') return;
            
            if (target.classList.contains('shape') || target.classList.contains('shape-text')) {
                const id = parseInt(target.getAttribute('data-id'));
                const shape = shapes.find(s => s.id === id);
                
                if (shape) {
                    const canvasCoords = getCanvasCoordinates(e.clientX, e.clientY);
                    dragData = {
                        shape: shape,
                        startX: canvasCoords.x - shape.x,
                        startY: canvasCoords.y - shape.y,
                        type: 'shape'
                    };
                    
                    selectShape(id);
                    updateStatus('üß± Dragging shape...');
                }
            }
        });

        canvasContainer.addEventListener('mousemove', function(e) {
            // Handle panning
            if (isPanning) {
                pan(e);
                return;
            }
            
            const canvasCoords = getCanvasCoordinates(e.clientX, e.clientY);
            
            // Handle arrow endpoint dragging
            if (arrowDragData) {
                // Find the closest connection point
                const closestPoint = findClosestConnectionPoint(canvasCoords.x, canvasCoords.y, arrowDragData.arrow);
                
                if (closestPoint) {
                    // Update arrow connection
                    if (arrowDragData.endpoint === 'start') {
                        arrowDragData.arrow.startId = closestPoint.shapeId;
                        arrowDragData.arrow.startPoint = closestPoint.pointId;
                    } else {
                        arrowDragData.arrow.endId = closestPoint.shapeId;
                        arrowDragData.arrow.endPoint = closestPoint.pointId;
                    }
                    
                    updateArrowPosition(arrowDragData.arrow);
                }
                return;
            }
            
            // Handle resizing
            if (resizeData) {
                const deltaX = canvasCoords.x - resizeData.startX;
                const deltaY = canvasCoords.y - resizeData.startY;
                
                const minSize = 20;
                
                switch(resizeData.handleType) {
                    case 'se':
                        resizeData.shape.width = Math.max(minSize, resizeData.originalWidth + deltaX);
                        resizeData.shape.height = Math.max(minSize, resizeData.originalHeight + deltaY);
                        break;
                    case 'sw':
                        const newWidth = Math.max(minSize, resizeData.originalWidth - deltaX);
                        resizeData.shape.x = resizeData.originalX + resizeData.originalWidth - newWidth;
                        resizeData.shape.width = newWidth;
                        resizeData.shape.height = Math.max(minSize, resizeData.originalHeight + deltaY);
                        break;
                    case 'ne':
                        resizeData.shape.width = Math.max(minSize, resizeData.originalWidth + deltaX);
                        const newHeight = Math.max(minSize, resizeData.originalHeight - deltaY);
                        resizeData.shape.y = resizeData.originalY + resizeData.originalHeight - newHeight;
                        resizeData.shape.height = newHeight;
                        break;
                    case 'nw':
                        const newW = Math.max(minSize, resizeData.originalWidth - deltaX);
                        const newH = Math.max(minSize, resizeData.originalHeight - deltaY);
                        resizeData.shape.x = resizeData.originalX + resizeData.originalWidth - newW;
                        resizeData.shape.y = resizeData.originalY + resizeData.originalHeight - newH;
                        resizeData.shape.width = newW;
                        resizeData.shape.height = newH;
                        break;
                    case 'e':
                        resizeData.shape.width = Math.max(minSize, resizeData.originalWidth + deltaX);
                        break;
                    case 'w':
                        const newWW = Math.max(minSize, resizeData.originalWidth - deltaX);
                        resizeData.shape.x = resizeData.originalX + resizeData.originalWidth - newWW;
                        resizeData.shape.width = newWW;
                        break;
                    case 's':
                        resizeData.shape.height = Math.max(minSize, resizeData.originalHeight + deltaY);
                        break;
                    case 'n':
                        const newHH = Math.max(minSize, resizeData.originalHeight - deltaY);
                        resizeData.shape.y = resizeData.originalY + resizeData.originalHeight - newHH;
                        resizeData.shape.height = newHH;
                        break;
                }
                
                updateShapePosition(resizeData.shape);
                updateArrows();
                return;
            }
            
            // Handle dragging
            if (!dragData) return;
            
            if (dragData.type === 'text') {
                const x = canvasCoords.x - dragData.startX;
                const y = canvasCoords.y - dragData.startY;
                
                dragData.text.x = Math.max(0, x);
                dragData.text.y = Math.max(0, y);
                
                const textElement = document.querySelector(`.free-text[data-id="${dragData.text.id}"]`);
                if (textElement) {
                    textElement.setAttribute('x', dragData.text.x);
                    textElement.setAttribute('y', dragData.text.y);
                }
            } else if (dragData.type === 'shape') {
                const x = canvasCoords.x - dragData.startX;
                const y = canvasCoords.y - dragData.startY;
                
                dragData.shape.x = Math.max(0, x);
                dragData.shape.y = Math.max(0, y);
                
                updateShapePosition(dragData.shape);
                updateArrows();
                
            }
        });

        canvasContainer.addEventListener('mouseup', function() {
            // Handle end of panning
            if (isPanning) {
                stopPanning();
                return;
            }
            
            if (arrowDragData) {
                updateConnectionPointsVisibility();
                updateStatus('üèπ Arrow endpoint reconnected');
            } else if (dragData && dragData.type === 'text') {
                updateStatus('üìù Text moved');
            } else if (dragData && dragData.type === 'shape') {
                updateStatus('üß± Shape moved');
            } else if (resizeData) {
                updateStatus('üß± Shape resized');
            }
            
            dragData = null;
            resizeData = null;
            arrowDragData = null;
            
            // Update selection status after operations
            setTimeout(updateSelectionStatus, 10);
        });
        
        // Add zoom wheel event
        canvasContainer.addEventListener('wheel', handleWheel, { passive: false });
        
        // Add pan with spacebar
        document.addEventListener('keydown', function(e) {
            if (e.key === ' ' && !isPanning) {
                // Store current mode to restore later
                dragData = null;
                resizeData = null;
                arrowDragData = null;
                canvas.classList.add('pan-mode');
            }
            
            // Delete selected element with Delete key
            if (e.key === 'Delete' && selectedElement) {
                deleteSelected();
            }
        });
        
        document.addEventListener('keyup', function(e) {
            if (e.key === ' ') {
                canvas.classList.remove('pan-mode');
                stopPanning();
            }
        });

        function findClosestConnectionPoint(x, y, excludeArrow) {
            let closest = null;
            let minDistance = 30; // Maximum snap distance
            
            shapes.forEach(shape => {
                const points = connectionPoints[shape.type] || connectionPoints.rectangle;
                points.forEach(point => {
                    const pointPos = getConnectionPointPosition(shape, point.id);
                    const distance = Math.sqrt(
                        Math.pow(x - pointPos.x, 2) + Math.pow(y - pointPos.y, 2)
                    );
                    
                    if (distance < minDistance) {
                        closest = {
                            shapeId: shape.id,
                            pointId: point.id,
                            distance: distance
                        };
                        minDistance = distance;
                    }
                });
            });
            
            return closest;
        }

        function updateShapePosition(shape) {
            const group = document.querySelector(`g[data-id="${shape.id}"]`);
            if (!group) return;
            
            // Remove old shape element and create new one
            const oldShape = group.querySelector('.shape');
            const textElement = group.querySelector('.shape-text');
            
            if (oldShape) {
                group.removeChild(oldShape);
            }
            
            const newShapeElement = createShapeElement(shape);
            newShapeElement.classList.add('shape');
            newShapeElement.setAttribute('data-id', shape.id);
            newShapeElement.style.fill = shape.color || currentColor;
            
            if (selectedElement && selectedElement.id === shape.id) {
                newShapeElement.classList.add('selected');
            }
            
            group.insertBefore(newShapeElement, textElement);
            
            // Update text position (replace the existing text update lines)
            updateMultiLineText(textElement, shape.text, shape.x + shape.width / 2, shape.y + shape.height / 2);
            
            // Update resize handles and connection points
            updateResizeHandles(shape);
            updateConnectionPoints(shape);
            
            // Re-add event listeners
            newShapeElement.addEventListener('dblclick', () => editText(shape, textElement));
        }

        function updateResizeHandles(shape) {
            const group = document.querySelector(`g[data-id="${shape.id}"]`);
            const handlesGroup = group.querySelector('.resize-handles');
            
            if (!handlesGroup) return;
            
            const handles = handlesGroup.querySelectorAll('.resize-handle');
            const positions = [
                { x: shape.x, y: shape.y },
                { x: shape.x + shape.width/2, y: shape.y },
                { x: shape.x + shape.width, y: shape.y },
                { x: shape.x + shape.width, y: shape.y + shape.height/2 },
                { x: shape.x + shape.width, y: shape.y + shape.height },
                { x: shape.x + shape.width/2, y: shape.y + shape.height },
                { x: shape.x, y: shape.y + shape.height },
                { x: shape.x, y: shape.y + shape.height/2 }
            ];
            
            handles.forEach((handle, index) => {
                if (positions[index]) {
                    handle.setAttribute('cx', positions[index].x);
                    handle.setAttribute('cy', positions[index].y);
                }
            });
        }

        function updateArrows() {
            arrows.forEach(arrow => {
                updateArrowPosition(arrow);
            });
        }

        function updateArrowPosition(arrow) {
            const startShape = shapes.find(s => s.id === arrow.startId);
            const endShape = shapes.find(s => s.id === arrow.endId);
            
            if (!startShape || !endShape) return;
            
            const startPos = getConnectionPointPosition(startShape, arrow.startPoint);
            const endPos = getConnectionPointPosition(endShape, arrow.endPoint);
            
            const arrowGroup = document.querySelector(`.arrow-group[data-id="${arrow.id}"]`);
            if (!arrowGroup) return;
            
            const pathData = generateCompleteArrowPath(startPos, endPos, arrow.startPoint, arrow.endPoint);
            
            const arrowPath = arrowGroup.querySelector('.arrow');
            const selectionArea = arrowGroup.querySelector('.arrow-selection-area');
            const endpoints = arrowGroup.querySelectorAll('.arrow-endpoint');
            
            if (arrowPath) {
                arrowPath.setAttribute('d', pathData);
            }
            
            if (selectionArea) {
                selectionArea.setAttribute('d', pathData);
            }
            
            if (endpoints.length >= 2) {
                endpoints[0].setAttribute('cx', startPos.x);
                endpoints[0].setAttribute('cy', startPos.y);
                endpoints[1].setAttribute('cx', endPos.x);
                endpoints[1].setAttribute('cy', endPos.y);
            }
        }

        function editText(shape, textElement) {
            const textarea = document.createElement('textarea');
            textarea.value = shape.text;
            textarea.className = 'text-input';
            
            // Calculate position considering canvas transform
            const rect = canvasContainer.getBoundingClientRect();
            const posX = shape.x * canvasTransform.scale + shape.width/2 * canvasTransform.scale + canvasTransform.x + rect.left;
            const posY = shape.y * canvasTransform.scale + shape.height/2 * canvasTransform.scale + canvasTransform.y + rect.top;
            
            textarea.style.left = (posX - 50) + 'px';
            textarea.style.top = (posY - 25) + 'px';
            textarea.style.width = '160px';
            textarea.style.minHeight = '20px';
            textarea.style.resize = 'both';
            textarea.style.overflow = 'hidden';
            
            // Auto-resize function
            function autoResize() {
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
            }
            
            textarea.addEventListener('input', autoResize);
            
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            
            // Initial resize
            autoResize();
            
            function finishEdit() {
                shape.text = textarea.value || getDefaultText(shape.type);
                updateMultiLineText(textElement, shape.text, shape.x + shape.width / 2, shape.y + shape.height / 2);
                document.body.removeChild(textarea);
                updateSelectionStatus();
            }
            
            textarea.addEventListener('blur', finishEdit);
            // Remove the Enter key handler to allow line breaks
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    finishEdit();
                }
            });
        }

        function deleteShape(id) {
            shapes = shapes.filter(s => s.id !== id);
            
            // Remove connected arrows
            arrows = arrows.filter(a => {
                if (a.startId === id || a.endId === id) {
                    const arrowGroup = document.querySelector(`.arrow-group[data-id="${a.id}"]`);
                    if (arrowGroup) arrowGroup.remove();
                    return false;
                }
                return true;
            });
            
            // Remove shape element
            const group = document.querySelector(`g[data-id="${id}"]`);
            if (group) group.remove();
            
            clearSelection();
            
        }

        function deleteArrow(id) {
            arrows = arrows.filter(a => a.id !== id);
            const arrowGroup = document.querySelector(`.arrow-group[data-id="${id}"]`);
            if (arrowGroup) arrowGroup.remove();
            clearSelection();
        }

        // Export/Import functions
        function exportJSON() {
            const data = { shapes, arrows, freeTexts };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'flowchart.json';
            a.click();
            URL.revokeObjectURL(url);
            updateStatus('üì¶ Flowchart exported to JSON');
        }

        function exportSVG() {
            // Create a clean copy of the canvas
            const svgClone = canvas.cloneNode(true);
            svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            
            // Get the content bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            shapes.forEach(shape => {
                minX = Math.min(minX, shape.x);
                minY = Math.min(minY, shape.y);
                maxX = Math.max(maxX, shape.x + shape.width);
                maxY = Math.max(maxY, shape.y + shape.height);
            });
            
            freeTexts.forEach(text => {
                // Approximate text width based on content
                const approxWidth = text.text.length * 8;
                minX = Math.min(minX, text.x - approxWidth/2);
                minY = Math.min(minY, text.y - 10);
                maxX = Math.max(maxX, text.x + approxWidth/2);
                maxY = Math.max(maxY, text.y + 10);
            });
            
            // Add padding
            const padding = 20;
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX += padding;
            maxY += padding;
            
            const width = maxX - minX;
            const height = maxY - minY;
            
            svgClone.setAttribute('width', width);
            svgClone.setAttribute('height', height);
            svgClone.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
            
            // Remove interactive elements that shouldn't be in the export
            svgClone.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            svgClone.querySelectorAll('.resize-handles, .connection-points, .arrow-endpoints, .arrow-selection-area').forEach(el => el.remove());
            
            // Ensure all arrow markers are properly defined in the exported SVG
            const defsClone = svgClone.querySelector('defs');
            arrows.forEach(arrow => {
                if (arrow.color && arrow.color !== '#333333') {
                    let marker = defsClone.querySelector(`#arrowhead-${arrow.id}`);
                    if (!marker) {
                        marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                        marker.setAttribute('id', `arrowhead-${arrow.id}`);
                        marker.setAttribute('markerWidth', '10');
                        marker.setAttribute('markerHeight', '7');
                        marker.setAttribute('refX', '9');
                        marker.setAttribute('refY', '3.5');
                        marker.setAttribute('orient', 'auto');
                        
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                        polygon.setAttribute('fill', arrow.color);
                        marker.appendChild(polygon);
                        
                        defsClone.appendChild(marker);
                    }
                }
            });
            
            // Apply proper fill colors to shapes based on their stored colors
            shapes.forEach(shape => {
                const shapeGroup = svgClone.querySelector(`g[data-id="${shape.id}"]`);
                if (shapeGroup) {
                    const shapeElement = shapeGroup.querySelector('.shape');
                    if (shapeElement && shape.color) {
                        // Set fill attribute directly instead of relying on style
                        shapeElement.setAttribute('fill', shape.color);

                        // ADD STROKE BOUNDARIES TO SHAPES
                        shapeElement.setAttribute('stroke', '#333333');  // Dark gray border
                        shapeElement.setAttribute('stroke-width', '2');   // Border thickness

                        // Remove any conflicting style
                        shapeElement.removeAttribute('style');
                    }
                    
                    // Fix text positioning and attributes
                    const textElement = shapeGroup.querySelector('.shape-text');
                    if (textElement) {
                        // Ensure proper text positioning attributes
                        textElement.setAttribute('text-anchor', 'middle');
                        textElement.setAttribute('font-family', 'Courier New, monospace');
                        textElement.setAttribute('font-size', '14');
                        textElement.setAttribute('font-weight', 'bold');
                        textElement.setAttribute('fill', '#333');
                        textElement.setAttribute('stroke', 'none');
                        
                        // Remove any conflicting CSS classes and styles
                        textElement.removeAttribute('class');
                        textElement.removeAttribute('style');
                        
                        // Update multi-line text for export
                        updateMultiLineText(textElement, shape.text, shape.x + shape.width / 2, shape.y + shape.height / 2);
                    }
                }
            });
            
            // Apply proper stroke colors to arrows and ensure arrowheads are visible
            arrows.forEach(arrow => {
                const arrowGroup = svgClone.querySelector(`.arrow-group[data-id="${arrow.id}"]`);
                if (arrowGroup) {
                    const arrowElement = arrowGroup.querySelector('.arrow');
                    if (arrowElement) {
                        // Set stroke attribute directly
                        arrowElement.setAttribute('stroke', arrow.color || '#333333');
                        arrowElement.setAttribute('stroke-width', '2');
                        arrowElement.setAttribute('fill', 'none');
                        
                        // Set the correct marker reference
                        if (arrow.color && arrow.color !== '#333333') {
                            arrowElement.setAttribute('marker-end', `url(#arrowhead-${arrow.id})`);
                        } else {
                            arrowElement.setAttribute('marker-end', 'url(#arrowhead)');
                        }
                        
                        // Remove any conflicting style
                        arrowElement.removeAttribute('style');
                        arrowElement.removeAttribute('class');
                    }
                }
            });
            
            // Fix free text positioning and attributes
            freeTexts.forEach(text => {
                const textElement = svgClone.querySelector(`.free-text[data-id="${text.id}"]`);
                if (textElement) {
                    const approxWidth = text.text.length * 8;
                    textElement.setAttribute('x', text.x - approxWidth/2);
                    textElement.setAttribute('y', text.y + 3);
                    textElement.setAttribute('font-family', 'Courier New, monospace');
                    textElement.setAttribute('font-size', '14');
                    textElement.setAttribute('font-weight', 'bold');
                    textElement.setAttribute('fill', text.color || '#333');
                    textElement.setAttribute('stroke', 'none');
                    
                    // Remove any conflicting CSS classes and styles
                    textElement.removeAttribute('class');
                    textElement.removeAttribute('style');
                    
                    textElement.textContent = text.text;
                }
            });
            
            const svgData = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgClone.outerHTML;
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'flowchart.svg';
            a.click();
            URL.revokeObjectURL(url);
            updateStatus('üì¶ Flowchart exported to SVG with proper arrow heads and text positioning');
        }

        function importJSON(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    loadData(data);
                    // Remove this line to preserve original positions:
                    // centerViewOnFlowchart();
                    // Reset view to default position instead
                    resetZoom();
                    
                    updateStatus('üì¶ Flowchart imported successfully at original positions');
                } catch (error) {
                    alert('Invalid JSON file');
                    updateStatus('‚ùå Failed to import flowchart');
                }
            };
            reader.readAsText(file);
            input.value = "";
        }

        function loadData(data) {
            clearCanvas();
            shapes = data.shapes || [];
            arrows = data.arrows || [];
            freeTexts = data.freeTexts || [];
            
            const allIds = [...shapes, ...arrows, ...freeTexts].map(item => item.id);
            nextId = allIds.length > 0 ? Math.max(...allIds) + 1 : 1;
            
            shapes.forEach(renderShape);
            arrows.forEach(renderArrow);
            freeTexts.forEach(renderFreeText);
            
        }

        function clearCanvas() {
            document.querySelectorAll('g, .arrow-group, .free-text').forEach(el => el.remove());
            shapes = [];
            arrows = [];
            freeTexts = [];
            clearSelection();
            nextId = 1;
            updateStatus('üßπ Canvas cleared');
            
        }

        // Initialize
        updateDeleteButton();
        updateColorSelectorState();
        updateSelectionStatus();
        setupColorSelection();
        updateCanvasTransform();
        console.log('‚õèÔ∏è Minecraft-themed Flowchart app with AI generation and canvas panning support loaded!');
        
        // Handle pressing Enter on AI input
        aiInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                generateAIFlowchart();
            }
        });
    </script>

</body>
</html>
